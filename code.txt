<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alpine Rush: Sonic Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Russo+One&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            font-family: 'Russo One', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            z-index: 20;
        }
        .hud-text {
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000;
        }
        .scanlines {
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 3px 100%;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 10;
        }
        #menu {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 30;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        .visible { opacity: 1; pointer-events: all; }
        
        .souls-text {
            font-family: 'serif';
            color: #8a0e0e;
            font-size: 3.5rem;
            letter-spacing: 5px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(138, 14, 14, 0.8);
            opacity: 0;
            transform: scale(1.5);
            transition: all 2s ease-out;
        }
        .you-died-active { opacity: 1; transform: scale(1); }
        
        /* Sound Toggle */
        #soundBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 50;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            color: white;
            width: 40px; height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            pointer-events: all;
        }
        #soundBtn:hover { background: white; color: black; }

        /* Active Powerup Indicator */
        #powerupStatus {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .status-icon {
            width: 50px; height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            border: 3px solid white;
            box-shadow: 0 0 15px currentColor;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <!-- Sound Toggle -->
    <div id="soundBtn">üîá</div>

    <!-- Notification Overlay -->
    <div id="notification" class="absolute top-1/3 w-full text-center text-white text-4xl font-black drop-shadow-lg pointer-events-none transition-opacity duration-500 opacity-0 z-50" style="text-shadow: 0 0 20px gold;">
        LEVEL UP!
    </div>

    <!-- HUD -->
    <div id="hud" class="ui-layer hidden">
        <div class="flex justify-between items-start w-full">
            <div>
                <div class="text-white font-bold text-3xl hud-text tracking-tighter">
                    <span id="scoreDisplay">0</span> m
                </div>
                <div class="text-yellow-400 text-xs font-bold hud-text mt-1">HI: <span id="hudHighScore">0</span></div>
                <div id="levelBadge" class="px-3 py-1 rounded bg-green-600 text-white text-xs border border-white mt-2 inline-block shadow-[0_0_10px_rgba(0,255,0,0.5)]">
                    Green Circle
                </div>
            </div>
            
            <div class="text-right mr-12"> <!-- Margin right for sound btn -->
                <div class="text-blue-300 font-bold text-xl hud-text">SPD: <span id="speedDisplay">0</span></div>
                <div class="w-32 h-4 bg-gray-900 border border-white mt-1 rounded-full overflow-hidden relative box-content p-0.5">
                    <div id="boostBar" class="h-full bg-gradient-to-r from-orange-500 to-yellow-300 w-full rounded-full shadow-[0_0_10px_orange]"></div>
                </div>
            </div>
        </div>
        
        <div id="powerupStatus"></div>
    </div>

    <!-- Menu -->
    <div id="menu" class="visible">
        <div id="youDied" class="souls-text mb-4 text-center leading-tight">YOU DIED</div>
        
        <h1 id="gameTitle" class="text-6xl md:text-7xl font-black text-white italic transform -skew-x-12 mb-6 text-center drop-shadow-[0_0_15px_rgba(59,130,246,0.8)]">
            ALPINE<br><span class="text-transparent bg-clip-text bg-gradient-to-b from-cyan-300 to-blue-600">SONIC</span>
        </h1>
        
        <div class="bg-black/40 p-4 rounded-xl border border-white/20 backdrop-blur-md mb-8 text-center w-64 shadow-2xl">
            <div class="text-yellow-400 text-xs uppercase tracking-widest mb-1">Best Run</div>
            <div class="text-4xl text-white font-black"><span id="menuHighScore">0</span> m</div>
        </div>
        
        <div id="statsPanel" class="hidden text-center mb-8">
            <p class="text-gray-300 text-sm">THIS RUN</p>
            <p class="text-white text-5xl font-bold mb-2 drop-shadow-lg"><span id="finalScore">0</span> m</p>
        </div>

        <button id="startBtn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold text-xl py-4 px-12 rounded-full transform transition hover:scale-105 shadow-[0_0_20px_rgba(37,99,235,0.6)] border-2 border-blue-300">
            SHRED IT
        </button>
        
        <div class="mt-8 text-xs text-gray-400">
            Tap üîá to enable audio
        </div>
    </div>

<script>
/**
 * AUDIO ENGINE
 * Procedural synth for music and SFX
 */
const Audio = {
    ctx: null,
    enabled: false,
    musicOscillators: [],
    musicInterval: null,
    nextNoteTime: 0,
    beatCount: 0,
    tempo: 120,

    init: function() {
        if (!this.ctx) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
        }
        if (this.ctx.state === 'suspended') {
            this.ctx.resume();
        }
        this.enabled = true;
        this.updateIcon();
    },

    toggle: function() {
        if (!this.ctx) {
            this.init();
            return;
        }
        this.enabled = !this.enabled;
        if (!this.enabled) {
            this.stopMusic();
        } else {
            if(gameState === 'PLAYING') this.startMusic();
        }
        this.updateIcon();
    },

    updateIcon: function() {
        const btn = document.getElementById('soundBtn');
        btn.innerText = this.enabled ? "üîä" : "üîá";
    },

    // --- SFX ---
    playSFX: function(type) {
        if (!this.enabled || !this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);

        if (type === 'boost') {
            // Whoosh sound
            // Create noise buffer for wind
            const bufferSize = this.ctx.sampleRate * 1.0;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            
            // Filter sweep
            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(200, t);
            noiseFilter.frequency.exponentialRampToValueAtTime(3000, t + 0.5);
            
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.5, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(this.ctx.destination);
            noise.start(t);
            noise.stop(t + 0.5);
            return;
        }

        if (type === 'collect') {
            // High ping (powerup)
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, t);
            osc.frequency.exponentialRampToValueAtTime(1760, t + 0.1);
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            osc.start(t);
            osc.stop(t + 0.5);
        }

        if (type === 'smash') {
            // Heavy distortion impact
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t);
            osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.3);
            gain.gain.setValueAtTime(0.5, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            
            filter.type = 'lowpass';
            filter.frequency.value = 500;
            
            osc.start(t);
            osc.stop(t + 0.3);
        }

        if (type === 'crash') {
            // Noise crunch
            const bufferSize = this.ctx.sampleRate * 1.0;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = this.ctx.createGain();
            
            noiseGain.gain.setValueAtTime(0.5, t);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            
            noise.connect(noiseGain);
            noiseGain.connect(this.ctx.destination);
            noise.start(t);
            noise.stop(t + 0.5);
            
            // Low thud
            const thud = this.ctx.createOscillator();
            thud.frequency.setValueAtTime(150, t);
            thud.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
            const thudGain = this.ctx.createGain();
            thudGain.gain.setValueAtTime(0.5, t);
            thudGain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
            thud.connect(thudGain);
            thudGain.connect(this.ctx.destination);
            thud.start(t);
            thud.stop(t+0.5);
        }
    },

    // --- Music Sequencer ---
    startMusic: function() {
        if (!this.enabled || !this.ctx) return;
        this.nextNoteTime = this.ctx.currentTime;
        this.beatCount = 0;
        this.scheduleMusic();
    },

    stopMusic: function() {
        if(this.musicInterval) clearTimeout(this.musicInterval);
    },

    scheduleMusic: function() {
        // Lookahead
        while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
            this.playBeat(this.nextNoteTime);
            // 16th notes at 120bpm = 0.125s
            const secondsPerBeat = 60.0 / this.tempo; 
            this.nextNoteTime += (secondsPerBeat / 4); // 16th notes
            this.beatCount++;
        }
        if (this.enabled) {
            this.musicInterval = setTimeout(() => this.scheduleMusic(), 25);
        }
    },

    playBeat: function(time) {
        // Simple Synthwave Bass Loop
        // Pattern length 16 (1 bar)
        const beat = this.beatCount % 16;
        
        // Kick: 1, 5, 9, 13 (4 on the floor)
        if (beat % 4 === 0) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(0.8, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            osc.start(time);
            osc.stop(time + 0.5);
        }

        // Snare: 5, 13
        if (beat === 4 || beat === 12) {
            // Noise burst
            const bufferSize = this.ctx.sampleRate * 0.2;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            // Lowpass for darker snare
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 1000;
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            
            gain.gain.setValueAtTime(0.4, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            noise.start(time);
        }

        // Bassline (Running 8ths)
        // Notes: E (41.2Hz), G (49Hz), A (55Hz)
        if (beat % 2 === 0) {
            const osc = this.ctx.createOscillator();
            osc.type = 'sawtooth';
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);

            // Simple chord progression based on beatCount magnitude (every 32 beats change)
            const bar = Math.floor(this.beatCount / 16) % 4;
            let freq = 41.20; // E1
            if (bar === 1) freq = 49.00; // G1
            if (bar === 2) freq = 55.00; // A1
            if (bar === 3) freq = 41.20; // E1
            
            // Octave jump for energy
            if (beat % 4 === 2) freq *= 2; 

            osc.frequency.setValueAtTime(freq, time);
            
            // Pluck filter envelope
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200, time);
            filter.frequency.exponentialRampToValueAtTime(100, time + 0.1);
            
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            
            osc.start(time);
            osc.stop(time + 0.25);
        }
    }
};

// ------------------------------
// GAME LOGIC (Integrated)
// ------------------------------

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// UI Refs
const menuEl = document.getElementById('menu');
const hudEl = document.getElementById('hud');
const startBtn = document.getElementById('startBtn');
const soundBtn = document.getElementById('soundBtn');
const scoreEl = document.getElementById('scoreDisplay');
const hudHighScoreEl = document.getElementById('hudHighScore');
const menuHighScoreEl = document.getElementById('menuHighScore');
const speedEl = document.getElementById('speedDisplay');
const boostBar = document.getElementById('boostBar');
const levelBadge = document.getElementById('levelBadge');
const notification = document.getElementById('notification');
const youDiedText = document.getElementById('youDied');
const statsPanel = document.getElementById('statsPanel');
const gameTitle = document.getElementById('gameTitle');
const finalScoreEl = document.getElementById('finalScore');
const powerupStatusEl = document.getElementById('powerupStatus');

// Data Persistence
let highScore = parseInt(localStorage.getItem('alpineSonicHighScore')) || 0;
menuHighScoreEl.innerText = highScore;
hudHighScoreEl.innerText = highScore;

// --- CONFIG ---
const LEVELS = [
    { threshold: 500, name: 'GREEN CIRCLE', color: '#16a34a', baseSpeed: 400, density: 0.35, sky: '#e0f7fa', snow: '#ffffff', night: false },
    { threshold: 1500, name: 'BLUE SQUARE', color: '#2563eb', baseSpeed: 600, density: 0.25, sky: '#bae6fd', snow: '#f0f9ff', night: false },
    { threshold: 3000, name: 'BLACK DIAMOND', color: '#1f2937', baseSpeed: 800, density: 0.18, sky: '#64748b', snow: '#e2e8f0', night: false },
    { threshold: Infinity, name: 'DOUBLE BLACK', color: '#991b1b', baseSpeed: 1000, density: 0.12, sky: '#0f172a', snow: '#334155', night: true }
];

// --- GAME STATE ---
let gameState = 'MENU';
let lastTime = 0;
let distance = 0;
let currentLevelIdx = 0;
let timeSinceObsSpawn = 0;
let timeSincePowerSpawn = 0;
let shake = 0;

// Pathing
let pathCenter = 0.5; 
let pathTarget = 0.5;

// Player
let player = {
    x: 0, y: 150, radius: 10,
    speedZ: 0, velocityX: 0,
    boost: 100, isBoosting: false,
    tilt: 0,
    invincibleTimer: 0,
    slowMoTimer: 0
};

let inputs = { left: false, right: false, boost: false };
let touchX = null;

// Entities
let obstacles = [];
let powerups = [];
let particles = [];
let floatTexts = [];

// Resize
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    if(gameState === 'MENU') player.x = canvas.width/2;
}
window.addEventListener('resize', resize);
resize();

// Controls
window.addEventListener('keydown', e => {
    if(['ArrowLeft','a'].includes(e.key)) inputs.left = true;
    if(['ArrowRight','d'].includes(e.key)) inputs.right = true;
    if([' ','ArrowUp'].includes(e.key)) inputs.boost = true;
});
window.addEventListener('keyup', e => {
    if(['ArrowLeft','a'].includes(e.key)) inputs.left = false;
    if(['ArrowRight','d'].includes(e.key)) inputs.right = false;
    if([' ','ArrowUp'].includes(e.key)) inputs.boost = false;
});
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    touchX = e.touches[0].clientX;
    if(e.touches.length > 1) inputs.boost = true;
}, {passive: false});
canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    touchX = e.touches[0].clientX;
}, {passive: false});
canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if(e.touches.length < 2) inputs.boost = false;
    setTimeout(() => { if(e.touches.length===0) touchX = null; }, 50);
});

// Sound Toggle Click
soundBtn.addEventListener('click', () => Audio.toggle());

// --- LOGIC ---

function startGame() {
    // Init Audio Context on first interaction
    if (!Audio.ctx) Audio.init();
    if (Audio.enabled) Audio.startMusic();

    gameState = 'PLAYING';
    menuEl.classList.add('hidden');
    menuEl.classList.remove('visible');
    hudEl.classList.remove('hidden');
    youDiedText.classList.remove('you-died-active');
    
    distance = 0;
    currentLevelIdx = 0;
    player.x = canvas.width/2;
    player.speedZ = LEVELS[0].baseSpeed;
    player.velocityX = 0;
    player.boost = 100;
    player.invincibleTimer = 0;
    player.slowMoTimer = 0;
    
    obstacles = [];
    powerups = [];
    particles = [];
    floatTexts = [];
    
    updateLevelDisplay();
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

function saveHighScore() {
    if (distance > highScore) {
        highScore = Math.floor(distance);
        localStorage.setItem('alpineSonicHighScore', highScore);
        menuHighScoreEl.innerText = highScore;
        hudHighScoreEl.innerText = highScore;
    }
}

function gameOver() {
    gameState = 'GAMEOVER';
    Audio.stopMusic();
    Audio.playSFX('crash');
    
    saveHighScore();
    hudEl.classList.add('hidden');
    menuEl.classList.remove('hidden');
    menuEl.classList.add('visible');
    gameTitle.classList.add('hidden');
    statsPanel.classList.remove('hidden');
    youDiedText.classList.add('you-died-active');
    finalScoreEl.innerText = Math.floor(distance);
    
    youDiedText.innerText = (distance >= highScore && distance > 100) ? "NEW RECORD!" : "YOU DIED";
    youDiedText.style.color = (distance >= highScore && distance > 100) ? "#fbbf24" : "#8a0e0e";
}

function updateLevelDisplay() {
    const lvl = LEVELS[currentLevelIdx];
    levelBadge.innerText = lvl.name;
    levelBadge.style.backgroundColor = lvl.color;
    levelBadge.style.boxShadow = `0 0 10px ${lvl.color}`;
}

function spawnFloatingText(text, x, y, color) {
    floatTexts.push({ text, x, y, color, life: 1.0, vy: -50 });
}

function spawnPowerup() {
    if (Math.random() > 0.3) {
        const types = ['JUGGERNAUT', 'ZEN', 'SCORE'];
        const type = types[Math.floor(Math.random() * types.length)];
        const spawnX = (pathCenter + (Math.random() * 0.2 - 0.1)) * canvas.width;
        
        powerups.push({
            type: type,
            x: spawnX,
            y: canvas.height + 50,
            radius: 15,
            angle: 0 
        });
    }
}

function spawnObstacle() {
    const lvl = LEVELS[currentLevelIdx];
    const spawnX = Math.random() * canvas.width;
    
    const safeMin = (pathCenter - lvl.density/2) * canvas.width;
    const safeMax = (pathCenter + lvl.density/2) * canvas.width;
    
    if (spawnX > safeMin && spawnX < safeMax && Math.random() > 0.1) return;

    const type = Math.random() > 0.7 ? 'ROCK' : 'TREE';
    obstacles.push({
        type: type,
        x: spawnX,
        y: canvas.height + 50,
        width: type === 'TREE' ? 40 : 30,
        height: 50,
        colorVariation: Math.random()
    });
}

function update(dt) {
    const lvl = LEVELS[currentLevelIdx];

    let nextLevelIdx = 0;
    for(let i=0; i<LEVELS.length; i++) if(distance >= LEVELS[i].threshold) nextLevelIdx = i + 1;
    if(nextLevelIdx < LEVELS.length && nextLevelIdx > currentLevelIdx) {
        currentLevelIdx = nextLevelIdx;
        updateLevelDisplay();
        notification.style.opacity = 1;
        setTimeout(() => notification.style.opacity = 0, 2000);
        
        // Increase Tempo with Level!
        Audio.tempo = 120 + (currentLevelIdx * 20);
    }

    if (player.invincibleTimer > 0) {
        player.invincibleTimer -= dt;
        if(player.invincibleTimer < 0) player.invincibleTimer = 0;
    }
    if (player.slowMoTimer > 0) {
        player.slowMoTimer -= dt;
        if(player.slowMoTimer < 0) player.slowMoTimer = 0;
    }

    let html = '';
    if(player.invincibleTimer > 0) html += `<div class="status-icon bg-red-600" style="color:white;">üî•</div>`;
    if(player.slowMoTimer > 0) html += `<div class="status-icon bg-cyan-500" style="color:white;">‚ùÑÔ∏è</div>`;
    powerupStatusEl.innerHTML = html;

    let speedMult = 1.0;
    let dtGame = dt; 
    if (player.slowMoTimer > 0) {
        speedMult = 0.5; 
        dtGame = dt * 0.5; 
    }

    let targetSpeed = lvl.baseSpeed;
    
    // Boost
    if (inputs.boost && player.boost > 0) {
        if(!player.isBoosting) Audio.playSFX('boost'); // Play once
        targetSpeed *= 1.4;
        player.boost -= 30 * dt;
        player.isBoosting = true;
        if(Math.random() > 0.5) createParticle(player.x, player.y + 10, 'BOOST');
    } else {
        player.isBoosting = false;
        if(player.boost < 100) player.boost += 10 * dt;
    }
    
    player.speedZ += (targetSpeed - player.speedZ) * 2 * dt;
    distance += (player.speedZ * speedMult / 50) * dt; 
    
    const steerSpeed = 500 + (currentLevelIdx * 100);
    let targetVx = 0;
    if (touchX !== null) {
        const diff = touchX - player.x;
        if(Math.abs(diff) > 5) targetVx = Math.sign(diff) * steerSpeed;
    } else {
        if(inputs.left) targetVx = -steerSpeed;
        if(inputs.right) targetVx = steerSpeed;
    }
    
    player.velocityX += (targetVx - player.velocityX) * 10 * dt;
    player.x += player.velocityX * dt;
    
    if(player.x < 0) { player.x = 0; player.velocityX *= -0.5; }
    if(player.x > canvas.width) { player.x = canvas.width; player.velocityX *= -0.5; }
    player.tilt = player.velocityX / steerSpeed;

    if (Math.random() < 0.05) pathTarget = 0.2 + Math.random() * 0.6;
    if (pathCenter < pathTarget) pathCenter += 0.2 * dtGame;
    if (pathCenter > pathTarget) pathCenter -= 0.2 * dtGame;

    timeSinceObsSpawn += dtGame;
    if (timeSinceObsSpawn > (lvl.density * (1000/player.speedZ))) {
        spawnObstacle();
        timeSinceObsSpawn = 0;
        if(currentLevelIdx >= 2 && Math.random() > 0.5) spawnObstacle();
    }
    
    timeSincePowerSpawn += dtGame;
    if (timeSincePowerSpawn > 3.0) { 
        spawnPowerup();
        timeSincePowerSpawn = 0;
    }

    // --- Entities ---
    
    obstacles.forEach(ob => ob.y -= player.speedZ * speedMult * dt);
    obstacles = obstacles.filter(ob => ob.y > -100);
    
    powerups.forEach(p => {
        p.y -= player.speedZ * speedMult * dt;
        p.angle += 5 * dt;
    });
    powerups = powerups.filter(p => p.y > -100);

    // Powerup Collisions
    for (let i = powerups.length - 1; i >= 0; i--) {
        let p = powerups[i];
        const dist = Math.hypot(player.x - p.x, player.y - p.y);
        if (dist < player.radius + p.radius + 10) {
            // SOUND EFFECT
            Audio.playSFX('collect');
            
            if (p.type === 'JUGGERNAUT') {
                player.invincibleTimer = 5.0;
                spawnFloatingText("SMASH MODE!", player.x, player.y, '#ef4444');
                shake = 10;
            } else if (p.type === 'ZEN') {
                player.slowMoTimer = 6.0;
                spawnFloatingText("ZEN TIME", player.x, player.y, '#06b6d4');
            } else if (p.type === 'SCORE') {
                distance += 500;
                spawnFloatingText("+500m", player.x, player.y, '#fbbf24');
            }
            for(let k=0; k<10; k++) createParticle(p.x, p.y, 'SPARK', p.type);
            powerups.splice(i, 1);
        }
    }
    
    // Obstacle Collisions
    for (let i = obstacles.length - 1; i >= 0; i--) {
        let ob = obstacles[i];
        const hw = ob.width * 0.6;
        const hh = ob.height * 0.4;
        
        if (Math.abs(player.x - ob.x) < (hw/2 + player.radius) &&
            Math.abs(player.y - (ob.y - 20)) < (hh/2 + player.radius)) {
            
            if (player.invincibleTimer > 0) {
                // SMASH SOUND
                Audio.playSFX('smash');
                
                shake = 5;
                spawnFloatingText("SMASH!", ob.x, ob.y, '#fff');
                for(let k=0; k<8; k++) createParticle(ob.x, ob.y, 'DEBRIS', ob.type === 'TREE' ? '#5d4037' : '#78909c');
                obstacles.splice(i, 1);
            } else {
                gameOver();
            }
        }
    }

    particles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt * (p.type === 'BOOST' ? 3 : 1);
    });
    particles = particles.filter(p => p.life > 0);
    
    floatTexts.forEach(t => {
        t.y += t.vy * dt;
        t.life -= dt;
    });
    floatTexts = floatTexts.filter(t => t.life > 0);
    
    if (shake > 0) shake *= 0.9;
    if (shake < 0.5) shake = 0;
}

function createParticle(x, y, type, subType) {
    let color = '#fff';
    let speed = 100;
    let life = 1.0;
    
    if (type === 'BOOST') { color = '#fcd34d'; speed = 50; }
    if (type === 'DEBRIS') { color = subType; speed = 200; } 
    if (type === 'SPARK') {
        if (subType === 'JUGGERNAUT') color = '#ef4444';
        else if (subType === 'ZEN') color = '#06b6d4';
        else color = '#fbbf24';
        speed = 150;
    }

    particles.push({
        x: x, y: y,
        vx: (Math.random() - 0.5) * speed,
        vy: (Math.random() - 0.5) * speed,
        life: life,
        color: color,
        size: Math.random() * 4 + 1,
        type: type
    });
}

// --- DRAWING ---

function draw() {
    const lvl = LEVELS[currentLevelIdx];
    
    ctx.save();
    if (shake > 0) {
        ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
    }

    ctx.fillStyle = lvl.snow;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    let allObjs = [...obstacles, ...powerups].sort((a,b) => a.y - b.y);
    
    allObjs.forEach(obj => {
        if(obj.type === 'JUGGERNAUT' || obj.type === 'ZEN' || obj.type === 'SCORE') drawPowerup(obj);
        else drawObstacle(obj);
    });

    drawPlayer();
    
    particles.forEach(p => {
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
    });
    ctx.globalAlpha = 1.0;
    
    floatTexts.forEach(t => {
        ctx.globalAlpha = t.life;
        ctx.fillStyle = t.color;
        ctx.font = "bold 20px sans-serif";
        ctx.strokeStyle = "black";
        ctx.lineWidth = 3;
        ctx.strokeText(t.text, t.x - 20, t.y);
        ctx.fillText(t.text, t.x - 20, t.y);
    });
    ctx.globalAlpha = 1.0;

    if (lvl.nightMode) {
        const grad = ctx.createRadialGradient(player.x, player.y + 50, 30, player.x, player.y + 100, 400);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.95)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,canvas.width, canvas.height);
    }
    
    if (player.slowMoTimer > 0) {
        ctx.fillStyle = `rgba(6, 182, 212, ${Math.min(0.2, player.slowMoTimer/10)})`;
        ctx.fillRect(0,0,canvas.width, canvas.height);
    }
    
    ctx.restore(); 

    scoreEl.innerText = Math.floor(distance);
    speedEl.innerText = Math.floor(player.speedZ / 10);
    boostBar.style.width = `${player.boost}%`;
    boostBar.className = player.boost < 20 
        ? "h-full w-full rounded-full shadow-[0_0_10px_red] bg-red-500 animate-pulse"
        : "h-full bg-gradient-to-r from-orange-500 to-yellow-300 w-full rounded-full shadow-[0_0_10px_orange]";
}

function drawPowerup(p) {
    ctx.save();
    ctx.translate(p.x, p.y);
    
    let color = '#fff';
    if(p.type === 'JUGGERNAUT') color = '#ef4444';
    if(p.type === 'ZEN') color = '#06b6d4';
    if(p.type === 'SCORE') color = '#fbbf24';
    
    ctx.shadowColor = color;
    ctx.shadowBlur = 20;
    
    const bob = Math.sin(Date.now() / 200) * 5;
    
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(0, -15 + bob, 12, 0, Math.PI*2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'white';
    ctx.font = "bold 14px sans-serif";
    ctx.textAlign = "center";
    let icon = "‚ö°";
    if(p.type === 'JUGGERNAUT') icon = "üî•";
    if(p.type === 'ZEN') icon = "‚ùÑÔ∏è";
    ctx.fillText(icon, 0, -10 + bob);
    
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, -15 + bob, 16, 0 + p.angle, 4 + p.angle);
    ctx.stroke();
    
    ctx.restore();
}

function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.tilt * 0.5);
    
    if (player.invincibleTimer > 0) {
        ctx.shadowColor = '#ef4444';
        ctx.shadowBlur = 30;
        ctx.fillStyle = `rgba(239, 68, 68, ${Math.random() * 0.5})`;
        ctx.beginPath();
        ctx.arc(0, 0, 25, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.shadowBlur = 0;
    ctx.fillStyle = '#222';
    ctx.fillRect(-8, -10, 4, 30);
    ctx.fillRect(4, -10, 4, 30);
    
    ctx.fillStyle = player.invincibleTimer > 0 ? '#ef4444' : '#2563eb'; 
    ctx.beginPath(); ctx.arc(0, 0, 10, 0, Math.PI*2); ctx.fill();
    
    ctx.fillStyle = '#111';
    ctx.beginPath(); ctx.arc(0, -8, 8, 0, Math.PI*2); ctx.fill();
    
    ctx.fillStyle = '#fbbf24'; 
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 5;
    ctx.fillRect(-5, -10, 10, 4);
    ctx.shadowBlur = 0;
    
    if(player.isBoosting || player.invincibleTimer > 0) {
        ctx.fillStyle = player.invincibleTimer > 0 ? '#ef4444' : '#f59e0b'; 
        ctx.beginPath(); 
        const tipY = -20 - Math.random()*5;
        const tipX = Math.random()*4 - 2;
        ctx.moveTo(0,0); ctx.lineTo(-10 + tipX, tipY); ctx.lineTo(10 + tipX, tipY); 
        ctx.fill();
    }

    ctx.restore();
}

function drawObstacle(ob) {
    ctx.save();
    ctx.translate(ob.x, ob.y);
    
    if(ob.type === 'TREE') {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 0, ob.width/2, 8, 0, 0, Math.PI*2); ctx.fill(); 
        
        ctx.fillStyle = '#3e2723'; 
        ctx.fillRect(-4, -ob.height*0.2, 8, ob.height*0.2);
        
        let treeColor = LEVELS[currentLevelIdx].nightMode ? '#0d2b10' : (ob.colorVariation > 0.5 ? '#15803d' : '#166534');
        ctx.fillStyle = treeColor;
        
        ctx.beginPath(); ctx.moveTo(-ob.width/2, -ob.height*0.2); ctx.lineTo(0, -ob.height*0.6); ctx.lineTo(ob.width/2, -ob.height*0.2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-ob.width*0.4, -ob.height*0.5); ctx.lineTo(0, -ob.height*0.8); ctx.lineTo(ob.width*0.4, -ob.height*0.5); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-ob.width*0.25, -ob.height*0.75); ctx.lineTo(0, -ob.height); ctx.lineTo(ob.width*0.25, -ob.height*0.75); ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.moveTo(0, -ob.height); ctx.lineTo(-3, -ob.height+5); ctx.lineTo(3, -ob.height+5); ctx.fill();

    } else {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(0, 4, ob.width/2, 6, 0, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = '#475569';
        ctx.beginPath(); ctx.arc(0, 0, ob.width/2, Math.PI, 0); ctx.fill();
        
        ctx.fillStyle = '#94a3b8';
        ctx.beginPath(); ctx.moveTo(-5, -5); ctx.lineTo(0, -10); ctx.lineTo(5, -5); ctx.fill();
    }
    
    ctx.restore();
}

function gameLoop(timestamp) {
    if (gameState !== 'PLAYING') {
        if(gameState !== 'MENU') draw(); 
        requestAnimationFrame(gameLoop);
        return;
    }
    
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    
    update(dt);
    draw();
    
    requestAnimationFrame(gameLoop);
}

startBtn.addEventListener('click', startGame);
</script>
</body>
</html>